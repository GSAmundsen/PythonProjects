import sys
import getopt
import datetime
import os
import requests
from bs4 import BeautifulSoup
from tkinter import *
from tkinter.ttk import *



#Using this to inform the user of the save location when saving using the GUI
lastFileSavedLocation = ""
startGUI = True

#Takes a list of common subdomains and a target website.Sets the default list to contain www,
def scan_subdomains(subdomains:list=["www"], site:str="")->list:
    """This function takes a list of common subdomains, and a target website and formats the URL so that it
        can be used by the Requests module to check if the subdomain returns with a 200 response code.
        This function returns a list of all URL's that returns a 200 response code."""

    subs = []

    #Splits the website address at the first . and pre-pends each string in the subdomains list before testing.
    site = site.split(".",1)[1] #Split once, and keep the latter part.

    for sub in subdomains:
        #response = 0 #Sets the response code to 0
        try:
            target = "http://{}.{}".format(sub,site)
            response = requests.get(target).status_code
            if response == 200 and target not in subs:
                subs.append(target)
                print("Status Code: {} - {}".format(response, target))

        except requests.ConnectionError:
            pass

    return subs

#This needs a website, or subdomain.website as a list, basic list should be a list with site as first index.
#Returns a list of folders, files in separate function?
def scan_subdirectories(dirs:list=[], site:str= "") -> list:
    """Takes a list of URLS generated by the scan_subdomains function, or a website URL. Looks for
        subdirectories, and searches through each found directory for more until it doesnt find anything not
        already in the list."""

    paths = []
    #If the list is empty(default) and a website string is given, make the list of paths to scan, the website.
    if len(paths) == 0 and site != "":
        paths = [site]
    else:
        # If we make a reference, like paths = dirs, the dirs list will change.
        # Making a 'slice' creates a new "object"
        paths = dirs[:]

    i = 0
    # While the counter i is smaller than the number of elements in the list
    # For each new directory that is found, increases the length of the list.
    while i < len(paths):
            if not paths[i].endswith("/"):
                paths[i] = paths[i]+ "/"
            # Get the current item in the list
            r = requests.get(paths[i])
            # Parses the HTML code
            soup = BeautifulSoup(r.text, "html.parser")
            # Finds all anchors in the parsed HTML code
            links = soup.find_all("a")
            # Looks for references to other resources
            for l in links:
                txt = l.get("href")  # get the value for href
                # If if ends with / its a folder, but we dont want ../ as that is the parent folder.
                if txt.endswith("/") and not txt.startswith("../"):
                    # If [currenturl]/[foundFolder] is not already in the list
                    if paths[i] + txt not in paths:
                        paths.append(paths[i] + txt)
            # Increase the counter
            i += 1
    return paths

def scan_files(pathsToScan:list=[], site:str="", searchFor:str="") -> list:
    """This function takes either a list of already discovered subdomains/directories, or a single URL and
        searches for files. The 'searchFor' variable works as an optional filter"""

    files = []
    #If no list is given, but a website is.
    if len(pathsToScan)==0 and site != "":
        pathsToScan = [site]

    # Goes through all the elements in the list of paths to scan
    for p in pathsToScan:
        r = requests.get(p)
        soup = BeautifulSoup(r.text, "html.parser")
        links = soup.find_all("a")
        # Gets the value of the href in the HTML code, and filters out elements.
        for l in links:
            file = l.get("href")
            if not file.endswith("/") and not file.startswith("../") and not file.startswith("http"):
                if searchFor in file:
                    files.append(p+file)

    return files

def create_list_from_file(filename:str) -> list:
    """Reads through a textfile line by line, generating a list of strings"""

    #Opens the file, and reads all lines into a list named "data"
    with open(filename, "r") as file:
        data = file.read().splitlines() #Removes \n in each line
        file.close()

    #Removes "Credits" lines if present in wordlist file.
    for line in data:
        if line.startswith("#"):
            data.remove(line)

    #If the data list contains more than 0 entries, return it.
    if len(data)>0:
        print("List generated, containing [{}] entries".format(len(data)))
        return data
    else:
        print("Could not generate list")

def discover_wordlists() -> list:
    """Goes through the files in the current working directory, filters out files ending in .txt, and adds them to a list,
        and returning the list."""

    temp_fileList = os.listdir()
    fileList = []

    for files in temp_fileList:
        if ".txt" in files:
            fileList.append(files)
    fileList.sort() #Sorts the list
    # Returns a list of files, empty if no files matches the filter (".txt")
    return fileList

def save_results_to_file(websitename:str, subdomains:list=[], directories:list=[], files:list=[]):
    """ Writes the discovered items to a file. The websitename is required, as that is used as part of the
        filename."""

    #Saved file location string used for the GUI
    global lastFileSavedLocation

    try:
       #Splits the string once, at first . and keeps the last part.
       with open(websitename.split(".",1)[1] + "_Scanned.txt", "a+") as file:  # Create or Open an existing file for appending and reading
           file.write("\n------[ {} ]------\n".format(datetime.datetime.now()))
           file.write("\nSubdomains: \n"+"--"*20+"\n")
           # Using an inline for loop to write each line with a newline. Writelines concatenates everything
           file.writelines(line + "\n" for line in subdomains)
           file.write("\nDirectories: \n"+"--"*20+"\n")
           file.writelines(line + "\n" for line in directories)
           file.write("\nFiles: \n"+"--"*20+"\n")
           file.writelines(line + "\n" for line in files)

           file.close()
           lastFileSavedLocation = os.path.abspath(file.name)
           print("Save Successful. \n{}".format(lastFileSavedLocation))
    # If there is an Input Output error, if the file cannot be opened, or no write permission etc..
    except IOError as e:
        print("Save Failed: {}".format(e))


def main(argv):
    """This function should only run when the program is started from the commandline.
        It takes a -target (website) and can scan it for subdomains using a dictionary, for directories, or files with
        an optional filter. Using the argument '-s' saves the result to a file in the current directory, -h prints
        the "help" text."""

    foundSubdomains = []
    foundDirectories = []
    foundFiles = []
    targetWebsite = ""
    searchforfiles = False
    searchfilename = ""
    saveResult = False

    # Tries to get passed arguments
    try:
       opts, args = getopt.getopt(argv,"hsfpt:d:n:",["target=","subs=", "name="])
    except getopt.GetoptError:
        print("Scan a website for subdomains, directories and files. \n\n"
             "Usage:\n" +
             "-" + "\n"
             "Args:\n"
             "-h: Shows this help text\n"
             "-f: Finds textfiles to use as a 'dictionary' in searching for subdomains.\n"
             "-t <keyword>: Scans the given website for subdirectories\n"
             "-d <keyword>: Searches for subdomains on the target website (-t), using the name of the list.\n"
             "-n <keyword>: Searches for a file with the given name (full or partial). Use -n with "" as keyword to list all files\n"
             "-s: Saves the result to a file in the programs folder, appends if the file exists.\n"
             "-gui: Starts the interactive GUI version\n"
             "-cmd: Starts the interactive commandline version\n"
             "-\n"
             "DirectoryBuster.py -f :Finds textfiles in working directory\n"
             "DirectoryBuster.py -t www.example.com -d CommonSubdomains.txt -n login.html\n"
             "Use interactive GUI: DirectoryBuster.py -gui\n"
              "Use interactive commandline: DirectoryBuster.py -cmd")
        sys.exit()

    #Iterates through the arguments, and assigns the corresponding value (arg) to the matching variables (opt)
    for opt, arg in opts:
        if opt == "-h":
           print("Scan a website for subdomains, directories and files. \n\n"
                 "Usage:\n",
                "-"*40, "\n"
                "Args:\n"
                "-h: Shows this help text\n"
                "-f: Finds textfiles to use as a 'dictionary' in searching for subdomains.\n"
                "-t <keyword>: Scans the given website for subdirectories\n"
                "-d <keyword>: Searches for subdomains on the target website (-t), using the name of the list.\n"
                "-n <keyword>: Searches for a file with the given name (full or partial). Use -n with "" as keyword to list all files\n"
                "-s: Saves the result to a file in the programs folder, appends if the file exists.\n"
                "-gui: Starts the interactive GUI version\n"
                "-cmd: Starts the interactive commandline version\n",
                "-"*40,"\n"
                "DirectoryBuster.py -f :Finds textfiles in working directory\n"
                "DirectoryBuster.py -t www.example.com -d CommonSubdomains.txt -n login.html -s\n"
                "Use interactive GUI: DirectoryBuster.py -gui\n"
                "Use interactive commandline: DirectoryBuster.py -cmd")
           sys.exit()
        elif opt in ("-f"):
           print(discover_wordlists())
        elif opt in ("-t", "--target"):
           targetWebsite = arg
        elif opt in ("-d", "--subfile"):
           sublist = create_list_from_file(arg)
           foundSubdomains = scan_subdomains(sublist, targetWebsite)
        elif opt in ("-n", "--name"):
           searchfilename = arg
           searchforfiles = True
        elif opt in ("-s"):
           saveResult = True

    # Checks that a website string is given, and appents http:// if not present.
    if targetWebsite != "":
        if "http" not in targetWebsite[0:4]:
            targetWebsite = "http://" + targetWebsite
        response = requests.get(targetWebsite).status_code
        if response == 200:
            print("\n{} returned with response code {}. OK".format(targetWebsite, 200))
            # If the list is not empty, pass it to the next scan.
            if len(foundSubdomains)>0:
                print("\nSubdomains: ", *foundSubdomains, sep="\n")
                foundDirectories = scan_subdirectories(foundSubdomains)
            # If it was empty, use the given URL to scan for subdirectories.
            else:
                foundDirectories = scan_subdirectories(site=targetWebsite)
            print("\nDirectories: ",*foundDirectories, sep="\n")

            # If the users wanted to search for files, use found directories as paths to scan, and provide the filter
            # If the filter searchFor is "" it returns everything.
            if searchforfiles:
                foundFiles = scan_files(foundDirectories, searchFor=searchfilename)
                print("\nFiles: ",*foundFiles, sep="\n")

            if saveResult:
                save_results_to_file(targetWebsite, foundSubdomains, foundDirectories, foundFiles)
            else:
                print("\nResult not saved")

    sys.exit()


if sys.stdin and sys.stdin.isatty():
    """This checks if arguments are passed to the program through the commandline. It will switch between GUI, commandline
        and taking arguments depending on input. """

    # This will have a minimum length of 1, since the name of the script is index 0
    if len(sys.argv) > 1:
        # If this argument is recieved, set the startGUI bool and skip other args.
        if sys.argv[1] == "-gui":
            startGUI = True
            pass
        # If this argumed is recieved, set the startGUI bool to False, and skip other args
        elif sys.argv[1] == "-cmd":
            startGUI = False
            pass
        else:
            main(sys.argv[1:])

    # If the program is run from the commandline, without arguments, the 'main' function
    # is run with the -h argument to help the user use it correctly.
    else:
        main(["-h"])
        sys.exit()


def btn_clicked_check_website(website:str):
    """Function used by the GUI, checks if the given website exists using a Request"""

    # If http is not present, add it, required by the Request module.
    if "http" not in website[0:4]:
        website = "http://" + website

    try:
        result = requests.get(website).status_code
        websiteresult_dynamic.set("{} responded with Code:{}".format(website,result))
        # If the scan is successful, unlocks the startScan button.
        btn_startScan["state"] = ACTIVE
        entry_website.delete(0, END)
        entry_website.insert(0, website)
    except:
        websiteresult_dynamic.set("{} could not be reached.".format(website))

def btn_clicked_reload_filelist():
    """Function used by the GUI, updates the drop-down list of text files used for scanning subdomains"""

    combo_subdomainFileList["values"] = discover_wordlists()
    combo_subdomainFileList.current(0)

def btn_clicked_start_scan(website:str, scansub:bool, subdomainfile:str, scanfile:bool, searchname:str, save:bool):
    """Function used by the GUI, takes all the variables entered by the user, and performs a scan on the
        target website."""

    #Closes the Results window, if open.
    resultWindow.withdraw()

    #Declares the variables so there is something to return if some scans are not run.
    foundsubs =[]
    founddirs = []
    foundfiles = []

    # If the user decided to scan for subdomains
    if scansub:
        sublist = create_list_from_file(subdomainfile)
        foundsubs = scan_subdomains(sublist, website)
        if len(foundsubs) >0:
            founddirs = scan_subdirectories(foundsubs)
        else:
            founddirs = scan_subdirectories(site=website)
    # Runs regardless since its result is used to scan for files
    else:
        founddirs = scan_subdirectories(site=website)

    # Looks for file matching the filter, if given
    if scanfile:
        foundfiles = scan_files(founddirs, searchFor=searchname)

    #Using Text area instead of Label so the user can CTRL-Copy.
    resultText.delete("1.0", END)
    resultText.insert("1.0", "Subdomains returned with Response Code: 200\n" + "\n".join(foundsubs))
    resultText.insert(END, "\n\nDirectories returned with Response Code: 200\n" + "\n".join(founddirs))
    resultText.insert(END, "\n\nFiles returned with Response Code: 200\n" + "\n".join(foundfiles))
    if save:
        save_results_to_file(website, foundsubs, founddirs, foundfiles)
        resultText.insert(END, "\n\n\n[File saved to: {}]".format(lastFileSavedLocation))

    # Shows the resultwindow after the text is set.
    resultWindow.deiconify()

if startGUI:
    """Code for the GUI, is the program is started with startGUI set to True"""
    window = Tk()
    window.geometry("500x550+100+300")
    window.title("Directory Buster v1")
    # A separate window to show the result of the scan
    resultWindow = Toplevel(window)
    resultWindow.geometry("700x500+605+300")
    # Starts withdraw, and gets spawned when results are ready
    resultWindow.withdraw()

    # Declaring dynamic variables
    websiteresult_dynamic = StringVar()
    websiteresult_dynamic.set("")
    checkboxVar_scansub = BooleanVar()
    checkboxVar_scansub.set(False)
    checkboxVar_scanfile = BooleanVar()
    checkboxVar_scanfile.set(False)
    checkboxVar_save = BooleanVar()
    checkboxVar_save.set(True)

    subscanresult_dynamic = StringVar()
    subscanresult_dynamic.set("")
    directoryscanresult_dynamic = StringVar()
    directoryscanresult_dynamic.set("")
    filescanresult_dynamic = StringVar()
    filescanresult_dynamic.set("")

    Label(window, text="Scan Website: (www.example.com)").pack(pady=2, side=TOP)
    entry_website = Entry(window, width=60)
    entry_website.pack(side=TOP)
    # Checks if the website exists and responds with code:200. Lambda required for the command to pass arguments
    Button(window, text="Check Website", command= lambda :btn_clicked_check_website(entry_website.get())).pack(pady=2, side=TOP)
    Label(window, textvariable=websiteresult_dynamic).pack(pady=5, side=TOP)
    Label(window, text="__" * 60).pack(pady=2, side=TOP)

    Label(window, text=" Please select scan options below. Leave empty to only scan for directories")

    checkbox_SubdomainScan = Checkbutton(window, text="Scan Subdomains", variable=checkboxVar_scansub)
    checkbox_SubdomainScan.pack(pady=2, side=TOP)
    combo_subdomainFileList = Combobox(window)
    combo_subdomainFileList.pack(pady=5, side=TOP)
    Button(window,text="Reload filelist", command=btn_clicked_reload_filelist()).pack(pady=2, side=TOP) #Using parenthesis to have the command run at start

    checkbox_FileScan = Checkbutton(window, text="Look for files", variable=checkboxVar_scanfile)
    checkbox_FileScan.pack(pady=2, side=TOP)
    Label(window, text="Enter a filename or extension to search for, full or partial(Ex. login).").pack(pady=2, side=TOP)
    entry_searchForFilename = Entry(window, width=60)
    entry_searchForFilename.pack(pady=2, side=TOP)
    Label(window, text="__" * 60).pack(pady=4, side=TOP)

    checkbox_SaveResult = Checkbutton(window, text="Save to file in working directory?", variable=checkboxVar_save)
    checkbox_SaveResult.pack(pady=2, side=TOP)
    # Button to start the scan using all entered information.
    btn_startScan = Button(window, text="Start Scan", command= lambda : btn_clicked_start_scan(entry_website.get(),
                                                                                               scansub=checkboxVar_scansub.get(),
                                                                                               subdomainfile=combo_subdomainFileList.get(),
                                                                                               scanfile=checkboxVar_scanfile.get(),
                                                                                               searchname=entry_searchForFilename.get(),
                                                                                               save=checkboxVar_save.get())
                           ,state=DISABLED) #Starts disabled until atleast a valid site is given.

    btn_startScan.pack(pady=2, side=TOP)

    # Result text area in the result window.
    resultText = Text(resultWindow, width=128, height=40)
    resultText.pack(pady=4, side=TOP, anchor=W)
    window.mainloop()


if not startGUI:
    """Code for the Non GUI version, if startGUI is set to False"""

    #Inputs from the user
    targetWebsite = input("Enter website to scan (www.example.com): ")
    scansubs = input("Scan for subdomains? (y/n): ")
    scansubdirs = input("Scan for subdirectories? (y/n)")
    scanfiles = input("Scan for files? (y/n): ")

    #Declaring variables, in case user only selects one or two options and not all
    foundSubdomains = []
    foundFiles = []
    foundDirectories = []


    #Add http if not in string
    if "http" not in targetWebsite[0:4]:
        targetWebsite = "http://"+targetWebsite

    # Check if the site exists
    try:
        code = 0 # Defines "code" in case requests fails.
        code = requests.get(targetWebsite).status_code
        print("{} returned with status code : {}".format(targetWebsite,code))
    except requests.ConnectionError:
        print ("Site does not exist")

    if code == 200:
        # creates a list of all .txt files (possible wordlists) in this programs folder
        wordfiles = discover_wordlists()
        while True:
            if scansubs.lower() == "y":
                #Prints a list of found .txt files, to use as a wordlist for subdomains.
                print("Text files found: ")
                for f in wordfiles:
                    print("[{}] - {}".format(wordfiles.index(f), f))

                # User selects a file by index or name
                selectSubDomainfile = input("Please select a wordlist to use to scan for subdomains, [Index] or name.txt: ")
                if selectSubDomainfile in wordfiles:
                    subDomainList = create_list_from_file(selectSubDomainfile)
                elif int(selectSubDomainfile) < len(wordfiles):
                    subDomainList = create_list_from_file(wordfiles[int(selectSubDomainfile)])

                # Scan for subdomains first, if user chose to. Using the subdomainlist and target
                foundSubdomains = scan_subdomains(subDomainList, targetWebsite)
                if len(foundSubdomains) > 0 and scansubs.lower()=="y":
                    print ("Subdomains found :\n"+"-"*30, *foundSubdomains, sep="\n")


            #Scans for directories if the user chooses to scan for either directories or files, as the result of this
            #is used to scan for files as well.
            if scansubdirs.lower()=="y" or scanfiles.lower()=="y":
                if len(foundSubdomains) > 0:
                    foundDirectories = scan_subdirectories(dirs=foundSubdomains)
                else:
                    foundDirectories = scan_subdirectories(site=targetWebsite)
                if len(foundDirectories) > 0 and scansubdirs.lower()=="y":
                    print("Sub-directories found :\n"+"-"*30, *foundDirectories, sep="\n")

            #If user chose to scan for files, scan using found subDirectories, or just the target website in no scan was done
            if scanfiles.lower() == "y":
                searchSpecificFiles = input(
                    "\nEnter name (full/partial) or file extension to search for, leave blank to search for everything: ")
                if len(foundDirectories) > 0:
                    foundFiles = scan_files(foundDirectories,searchFor=searchSpecificFiles)
                else:
                    foundFiles = scan_files(site=targetWebsite,searchFor=searchSpecificFiles)

                if len(foundFiles) > 0:
                    print("Files found :\n" + "-" * 30, *foundFiles, sep="\n")# Shorthand for printing each element with \n

            # Saves the result, Optional.
            saveresults = input("Save Results? (y/n): ")
            if saveresults.lower() == "y":
                save_results_to_file(targetWebsite, foundSubdomains, foundDirectories, foundFiles)


            break

